Traceback (most recent call last):
  File "/home/matthias/.local/lib/python3.10/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/usr/lib/python3/dist-packages/nbclient/client.py", line 1093, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/lib/python3/dist-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/usr/lib/python3/dist-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "/usr/lib/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/usr/lib/python3/dist-packages/nbclient/client.py", line 559, in async_execute
    await self.async_execute_cell(
  File "/usr/lib/python3/dist-packages/nbclient/client.py", line 854, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/usr/lib/python3/dist-packages/nbclient/client.py", line 756, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Load the CSV file
df = pd.read_csv('docs/owid-covid-data.csv')

# Convert the date column to datetime
df['date'] = pd.to_datetime(df['date'])

# Filter the data for the year 2021
df_2021 = df[df['date'].dt.year == 2021]

# Function to fill NaN values with the last available non-NaN value per country
def fill_last_available(df, col):
    return df.groupby('location')[col].fillna(method='ffill')

# Fill NaN values for the relevant columns
df_2021['excess_mortality_cumulative_per_million'] = fill_last_available(df_2021, 'excess_mortality_cumulative_per_million')
df_2021['people_fully_vaccinated_per_hundred'] = fill_last_available(df_2021, 'people_fully_vaccinated_per_hundred')

# Extract the last available data for each country
df_last_2021 = df_2021.groupby('location').last().reset_index()

# Create scatter plot for excess deaths vs people fully vaccinated
fig1 = px.scatter(df_last_2021, x='people_fully_vaccinated_per_hundred', y='excess_mortality_cumulative_per_million', 
                 trendline='ols', trendline_color_override='darkblue',
                 title='Excess mortality per million inhabitants vs. People fully vaccinated per hundred inhabitants, per country for 2021',
                 labels={'people_fully_vaccinated_per_hundred': 'People fully vaccinated per hundred inhabitants',
                         'excess_mortality_cumulative_per_million': 'Excess mortality cumulative per million inhabitants'},
                 hover_name='location', opacity=0.7)

# Grab the GDP per capita data for the last day of 2021
df_gdp = df[df['date'] == '2021-12-31']

# Create scatter plot for GDP vs people fully vaccinated
fig2 = px.scatter(df_gdp, x='people_fully_vaccinated_per_hundred', y=df.columns[52], 
                 trendline='ols', trendline_color_override='darkblue',
                 title='GDP per capita vs. People fully vaccinated per hundred inhabitants, per country for 2021',
                 labels={'people_fully_vaccinated_per_hundred': 'People fully vaccinated per hundred inhabitants',
                         df.columns[52]: 'GDP per capita'},
                 hover_name='location', opacity=0.7)

# Create a figure with subplots
fig = go.Figure()

# Add traces for the first plot
for trace in fig1.data:
    fig.add_trace(trace)

# Add traces for the second plot
for trace in fig2.data:
    fig.add_trace(trace)

# Update layout for buttons to toggle between plots
fig.update_layout(
    updatemenus=[
        dict(
            type="buttons",
            direction="left",
            buttons=list([
                dict(
                    args=[{"visible": [True] * len(fig1.data) + [False] * len(fig2.data)},
                          {"title": "Excess mortality per million inhabitants vs. People fully vaccinated per hundred inhabitants, per country for 2021"}],
                    label="Excess Deaths vs Vaccinations",
                    method="update"
                ),
                dict(
                    args=[{"visible": [False] * len(fig1.data) + [True] * len(fig2.data)},
                          {"title": "GDP per capita vs. People fully vaccinated per hundred inhabitants, per country for 2021"}],
                    label="GDP vs Vaccinations",
                    method="update"
                )
            ]),
            pad={"r": 10, "t": 10},
            showactive=True,
            x=0.57,
            xanchor="center",
            y=1.15,
            yanchor="top"
        ),
    ]
)

# Initially set the second plot to be not visible
for i in range(len(fig2.data)):
    fig.data[len(fig1.data) + i].visible = False

fig.show()

------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
[0;32m/tmp/ipykernel_84281/1991951373.py[0m in [0;36m<module>[0;34m[0m
[1;32m     24[0m [0;34m[0m[0m
[1;32m     25[0m [0;31m# Create scatter plot for excess deaths vs people fully vaccinated[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 26[0;31m fig1 = px.scatter(df_last_2021, x='people_fully_vaccinated_per_hundred', y='excess_mortality_cumulative_per_million', 
[0m[1;32m     27[0m                  [0mtrendline[0m[0;34m=[0m[0;34m'ols'[0m[0;34m,[0m [0mtrendline_color_override[0m[0;34m=[0m[0;34m'darkblue'[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
[1;32m     28[0m                  [0mtitle[0m[0;34m=[0m[0;34m'Excess mortality per million inhabitants vs. People fully vaccinated per hundred inhabitants, per country for 2021'[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/.local/lib/python3.10/site-packages/plotly/express/_chart_types.py[0m in [0;36mscatter[0;34m(data_frame, x, y, color, symbol, size, hover_name, hover_data, custom_data, text, facet_row, facet_col, facet_col_wrap, facet_row_spacing, facet_col_spacing, error_x, error_x_minus, error_y, error_y_minus, animation_frame, animation_group, category_orders, labels, orientation, color_discrete_sequence, color_discrete_map, color_continuous_scale, range_color, color_continuous_midpoint, symbol_sequence, symbol_map, opacity, size_max, marginal_x, marginal_y, trendline, trendline_options, trendline_color_override, trendline_scope, log_x, log_y, range_x, range_y, render_mode, title, template, width, height)[0m
[1;32m     64[0m     [0mmark[0m [0;32min[0m [0;36m2[0m[0mD[0m [0mspace[0m[0;34m.[0m[0;34m[0m[0;34m[0m[0m
[1;32m     65[0m     """
[0;32m---> 66[0;31m     [0;32mreturn[0m [0mmake_figure[0m[0;34m([0m[0margs[0m[0;34m=[0m[0mlocals[0m[0;34m([0m[0;34m)[0m[0;34m,[0m [0mconstructor[0m[0;34m=[0m[0mgo[0m[0;34m.[0m[0mScatter[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     67[0m [0;34m[0m[0m
[1;32m     68[0m [0;34m[0m[0m

[0;32m~/.local/lib/python3.10/site-packages/plotly/express/_core.py[0m in [0;36mmake_figure[0;34m(args, constructor, trace_patch, layout_patch)[0m
[1;32m   2265[0m                     [0mgroup[0m[0;34m[[0m[0mvar[0m[0;34m][0m [0;34m=[0m [0;36m100.0[0m [0;34m*[0m [0mgroup[0m[0;34m[[0m[0mvar[0m[0;34m][0m [0;34m/[0m [0mgroup_sum[0m[0;34m[0m[0;34m[0m[0m
[1;32m   2266[0m [0;34m[0m[0m
[0;32m-> 2267[0;31m             patch, fit_results = make_trace_kwargs(
[0m[1;32m   2268[0m                 [0margs[0m[0;34m,[0m [0mtrace_spec[0m[0;34m,[0m [0mgroup[0m[0;34m,[0m [0mmapping_labels[0m[0;34m.[0m[0mcopy[0m[0;34m([0m[0;34m)[0m[0;34m,[0m [0msizeref[0m[0;34m[0m[0;34m[0m[0m
[1;32m   2269[0m             )

[0;32m~/.local/lib/python3.10/site-packages/plotly/express/_core.py[0m in [0;36mmake_trace_kwargs[0;34m(args, trace_spec, trace_data, mapping_labels, sizeref)[0m
[1;32m    359[0m                     [0mtrace_patch[0m[0;34m[[0m[0;34m"x"[0m[0;34m][0m [0;34m=[0m [0msorted_trace_data[0m[0;34m[[0m[0margs[0m[0;34m[[0m[0;34m"x"[0m[0;34m][0m[0;34m][0m[0;34m[[0m[0mnon_missing[0m[0;34m][0m[0;34m[0m[0;34m[0m[0m
[1;32m    360[0m                     [0mtrendline_function[0m [0;34m=[0m [0mtrendline_functions[0m[0;34m[[0m[0mattr_value[0m[0;34m][0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 361[0;31m                     y_out, hover_header, fit_results = trendline_function(
[0m[1;32m    362[0m                         [0margs[0m[0;34m[[0m[0;34m"trendline_options"[0m[0;34m][0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
[1;32m    363[0m                         [0msorted_trace_data[0m[0;34m[[0m[0margs[0m[0;34m[[0m[0;34m"x"[0m[0;34m][0m[0;34m][0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/.local/lib/python3.10/site-packages/plotly/express/trendline_functions/__init__.py[0m in [0;36mols[0;34m(trendline_options, x_raw, x, y, x_label, y_label, non_missing)[0m
[1;32m     41[0m             )
[1;32m     42[0m [0;34m[0m[0m
[0;32m---> 43[0;31m     [0;32mimport[0m [0mstatsmodels[0m[0;34m.[0m[0mapi[0m [0;32mas[0m [0msm[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     44[0m [0;34m[0m[0m
[1;32m     45[0m     [0madd_constant[0m [0;34m=[0m [0mtrendline_options[0m[0;34m.[0m[0mget[0m[0;34m([0m[0;34m"add_constant"[0m[0;34m,[0m [0;32mTrue[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;31mModuleNotFoundError[0m: No module named 'statsmodels'
ModuleNotFoundError: No module named 'statsmodels'

